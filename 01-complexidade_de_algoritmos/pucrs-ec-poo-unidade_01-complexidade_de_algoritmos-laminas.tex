\documentclass[aspectratio=169]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}
\usepackage{ragged2e}
\usepackage{booktabs}
\usepackage{verbatim}
\usetheme{AnnArbor}
\usecolortheme{orchid}
\usefonttheme[onlymath]{serif}
\usepackage{listings}

\lstset{language=C,
	backgroundcolor=\color{green!10},
	basicstyle=\ttfamily,
	keywordstyle=\color{blue}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{green}\ttfamily,
	morecomment=[l][\color{magenta}]{\#}
}

\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

\title[\sc{Complexidade de Algoritmos}]{Complexidade de Algoritmos}
\author[Roland Teodorowitsch]{Roland Teodorowitsch}
\institute[ALEST I - EP - PUCRS]{Algoritmos e Estruturas de Dados I - Escola Politécnica - PUCRS}
\date{3 de agosto de 2023}

\begin{document}
\justifying

%-------------------------------------------------------
\begin{frame}
	\titlepage
\end{frame}

%=======================================================
\section{Apresentação}

%-------------------------------------------------------
\begin{frame}\frametitle{Leituras Recomendadas}

\begin{columns}[T]
\begin{column}{0.15\linewidth}
\vspace{-3mm}
\begin{figure}[h]
	\centering
	\includegraphics[height=0.3\paperheight]{pucrs-ec-poo-unidade_01-complexidade_de_algoritmos-laminas-livro_goodrich.jpg}
\end{figure}
\end{column}
\begin{column}{0.85\linewidth}
\vspace{3mm}
\textbf{Capítulo 4}\\
\scriptsize{GOODRICH, Michael T.; TAMASSIA, Roberto. \textbf{Estruturas de dados e algoritmos em Java}. Tradução: Bernardo Copstein. 5. ed. Porto Alegre: Bookman, 2013. xxii, 713 p. E-book. ISBN 9788582600191. Tradução de: Data Structures and Algorithms in Java, 5th Edition. Disponível em: \textless{}\url{https://integrada.minhabiblioteca.com.br/\#/books/9788582600191/}\textgreater{}. Acesso em: 01 ago. 2023.}
\end{column}
\end{columns}

\vspace{5mm}

\begin{columns}[T]
\begin{column}{0.15\linewidth}
\vspace{-3mm}
\begin{figure}[h]
	\centering
	\includegraphics[height=0.3\paperheight]{pucrs-ec-poo-unidade_01-complexidade_de_algoritmos-laminas-livro_cormen.jpg}
\end{figure}
\end{column}
\begin{column}{0.85\linewidth}
\vspace{3mm}
\textbf{Capítulo 3}\\
\scriptsize{CORMEN, Thomas \emph{et al}. \textbf{Algoritmos - Teoria e Prática}. Tradução: Arlete Simille Marques. Rio de Janeiro: Grupo GEN, 2012. E-book. ISBN 9788595158092. Tradução de: Introduction to Algorithms, 3rd ed. Disponível em: \textless{}\url{https://integrada.minhabiblioteca.com.br/\#/books/9788595158092/}\textgreater{}. Acesso em: 01 ago. 2023.}
\end{column}
\end{columns}

\end{frame}

%-------------------------------------------------------
\begin{frame}\frametitle{Sumário}
\begin{itemize}
	\item Complexidade e análise de algoritmos
	\item Medindo o tempo
	\item Contagem de operações
	\item Funções
\end{itemize}
\end{frame}

%=======================================================
\section{Complexidade e análise de algoritmos}

%-------------------------------------------------------
\begin{frame}\frametitle{Complexidade e análise de algoritmos}
\begin{itemize}
	\item  No desenvolvimento de uma aplicação tem-se como objetivo projetar ``boas'' estruturas de dados e ``bons'' algoritmos
	\begin{itemize}
		\item Otimizados
		\item Simples
	\end{itemize}
	\item Como saber se um algoritmo é eficiente?
\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}\frametitle{Análise de Algoritmos}
\begin{itemize}
	\item Estudo das características de desempenho de um determinado algoritmo
	\begin{itemize}
		\item O espaço ocupado é uma característica de desempenho
		\item O tempo gasto na execução é outra característica de desempenho
	\end{itemize}
\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}\frametitle{Complexidade de Algoritmos}
\begin{itemize}
	\item A \textbf{complexidade de um algoritmo} é a \textbf{medida do consumo de recursos} de que o algoritmo necessita durante a sua execução
	\begin{itemize}
		\item Tempo de processamento
		\item Memória ocupada
		\item Largura de banda de comunicação
		\item Hardware necessário
		\item etc.
	\end{itemize}
\end{itemize}
\end{frame}

%=======================================================
\section{Medindo o tempo}

%-------------------------------------------------------
\begin{frame}\frametitle{Tempo de processamento}
\begin{itemize}
	\item Depende de uma série de fatores: \emph{hardware}, \emph{software}, tamanho e tipo da entrada de dados
	\item Algoritmo: tempo de execução (ms) X tamanho da entrada de dados (n)
	\begin{figure}[h]
		\centering
		\includegraphics[height=0.6\paperheight]{pucrs-ec-poo-unidade_01-complexidade_de_algoritmos-laminas-grafico.jpg}
	\end{figure}
\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}[fragile]\frametitle{Medindo o tempo}
\begin{itemize}
	\item Em Java, \texttt{System.currentTimeMillis()} retorna o tempo em milissegundos (ms)
{\scriptsize
\begin{lstlisting}
long antes = System.currentTimeMillis();
// algoritmo a ser medido...
long ms = System.currentTimeMillis() - antes;
\end{lstlisting}}
	\item Em Java, \texttt{System.nanoTime()} retorna o tempo em nanossegundos (ns)
{\scriptsize
\begin{lstlisting}
long antes = System.nanoTime();
// algoritmo a ser medido...
long ns = System.nanoTime() - antes;
\end{lstlisting}}
	\item Em C, no Unix, pode-se usar \texttt{gettimeofday()} (incluir \texttt{<sys/time.h>})
{\scriptsize\begin{lstlisting}
struct timeval antes, depois;
gettimeofday(&antes, NULL);
// algoritmo a ser medido...
gettimeofday(&depois, NULL);
unsigned long us = (depois.tv_sec  - antes.tv_sec) * 1000000 +
                   depois.tv_usec - antes.tv_usec;
\end{lstlisting}}

\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}[fragile]\frametitle{Exemplo: Pesquisa Linear}
\begin{itemize}
	\item A função abaixo recebe um arranjo, o seu tamanho e um valor a ser localizado, e retorna a posição do valor no arranjo (ou -1 se não achar)
{\small\lstinputlisting{pesquisa_linear/pesquisa_linear.c}}
	\item Melhor caso: o valor procurado é o primeiro elemento do arranjo
	\item Pior caso: o valor procurado NÃO existe no arranjo
	\item O arranjo precisa estar ordenado?\\
	\pause
	\textbf{NÃO}
\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}[fragile]\frametitle{Exemplo: Pesquisa Linear}
\begin{itemize}
	\item Para visualizar como o algoritmo se comporta (``entender'' a sua complexidade), executa-se a função com valores crescentes de arranjo
{\fontsize{0}{6.4}\selectfont\lstinputlisting{pesquisa_linear/main.c}}
\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}[fragile]\frametitle{Exemplo: Pesquisa Linear (Resultado)}
\vspace{-5mm}
\begin{columns}[T]
\begin{column}{0.2\linewidth}{\tiny
\verbatiminput{pucrs-ec-poo-unidade_01-complexidade_de_algoritmos-laminas-inicio_curva_pesquisa_linear.txt}
}
\end{column}
\begin{column}{0.8\linewidth}
\begin{figure}[h]
	\centering
	\includegraphics[height=0.65\paperheight]{pucrs-ec-poo-unidade_01-complexidade_de_algoritmos-laminas-grafico_pesquisa_linear.jpg}
\end{figure}
\end{column}
\end{columns}
\end{frame}

%-------------------------------------------------------
\begin{frame}[fragile]\frametitle{Exemplo: Pesquisa Linear (Considerações)}
\begin{itemize}
	\item Considerando o algoritmo e a sua implementação, que tipo de curva de desempenho seria possível esperar?
	\item É possível visualizar a curva esperada no gráfico obtido?
	\item Qual a origem das variações do tempo de execução?
\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}[fragile]\frametitle{Exercício 1: \emph{Bubble Sort} (Linux)}
\begin{itemize}
	\item Implemente o algoritmo de ordenação \emph{BubbleSort}, por exemplo, a partir do pseudocódigo disponível na Wikipedia (\url{https://pt.wikipedia.org/wiki/Bubble_sort}) -- use o seguinte protótipo como modelo:
{\scriptsize
\begin{lstlisting}
void bubble_sort(int *dados, int tam);
\end{lstlisting}}
	\item Acrescente a sua implementação ao código da próxima página
	\begin{itemize}
		\item Este código trabalha com n variando de 1000 até 10000 com incremento 10, e medindo o tempo em microssegundos
	\end{itemize}
	\item Gere o gráfico de desempenho a partir da execução
	\begin{itemize}
		\item Salve seu código em um arquivo chamado \texttt{bubble\_sort.c} e compile-o usando:\\
		\texttt{gcc -o bubble\_sort bubble\_sort.c}
		\item Execute o programa direcionando a sua saída para um arquivo chamado \texttt{curva1.txt}:\\
		\texttt{./bubble\_sort \textgreater curva1.txt}
		\item Use o \textbf{GNUPLOT} para visualizar o arquivo \texttt{curva1.txt} (dicas nas próximas páginas)
	\end{itemize}
\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}[fragile]\frametitle{Exercício 1: \emph{Bubble Sort} (código da função \texttt{main()})}
{\fontsize{0}{6}\selectfont\lstinputlisting{bubble_sort/main.c}}
\end{frame}

%-------------------------------------------------------
\begin{frame}[fragile]\frametitle{Exercício 1: \emph{Bubble Sort} (dicas sobre \textbf{GNUPLOT})}
\begin{itemize}
	\item \textbf{GNUPLOT} é um aplicativo para gerar gráficos, disponível em várias plataformas
	\item Para mostrar, por exemplo, o gráfico correspondente aos dados armazenados no arquivo \texttt{curva1.txt} em uma janela, executa-se o \textbf{GNUPLOT} (\texttt{gnuplot}) e digita-se os seguintes comandos:
{\scriptsize
\begin{verbatim}
set xlabel "n" font "Arial,16"
set ylabel "t(us)" font "Arial,16"
plot "curva1.txt" with lines title "bubble\\_sort()"
\end{verbatim}
}
	\item Para gerar um arquivo JPEG com o conteúdo do gráfico, pode-se usar os seguintes comandos:
{\scriptsize
\begin{verbatim}
set terminal jpeg
set output "grafico1.jpg"
set xlabel "n" font "Arial,16"
set ylabel "t(us)" font "Arial,16"
plot "curva1.txt" with lines title "bubble\\_sort()"
\end{verbatim}
}
\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}[fragile]\frametitle{Solução 1: \emph{Bubble Sort} (primeira implementação)}
{\scriptsize\lstinputlisting{bubble_sort/bubble_sort1.c}}
\end{frame}

%-------------------------------------------------------
\begin{frame}[fragile]\frametitle{Solução 1: \emph{Bubble Sort} (gráfico da primeira implementação)}
\begin{figure}[h]
	\centering
	\includegraphics[height=0.75\paperheight]{pucrs-ec-poo-unidade_01-complexidade_de_algoritmos-laminas-grafico_bubble_sort1.jpg}
\end{figure}
\end{frame}

%-------------------------------------------------------
\begin{frame}[fragile]\frametitle{Exercício 2: \emph{Bubble Sort} otimizado}
\begin{itemize}
	\item A versão sugerida para implementação do \emph{Bubble Sort} tem um problema:
	\begin{itemize}
		\item Depois de executar uma passagem, o maior elemento é ``empurrado'' para a sua posição
		\item E: as passagens seguintes continuam ``tentado'' empurrar o maior elemento para o final
	\end{itemize}
	\item A solução consiste em diminuir gradualmente o tamanho até onde cada passagem é executada
	\item Implemente esta solução e compare o seu desempenho com a versão anterior
\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}[fragile]\frametitle{Solução 2: \emph{Bubble Sort} otimizado}
{\scriptsize\lstinputlisting{bubble_sort/bubble_sort2.c}}
\end{frame}

%-------------------------------------------------------
\begin{frame}[fragile]\frametitle{Solução 2: \emph{Bubble Sort} otimizado (comandos do \texttt{gnuplot})}
\begin{verbatim}
set xlabel "n" font "Arial,16"
set ylabel "t(us)" font "Arial,16"
plot "curva1.txt" with lines title "Bubble Sort",
     "curva2.txt" with lines title "Bubble Sort Otimizado"
\end{verbatim}
\end{frame}

%-------------------------------------------------------
\begin{frame}[fragile]\frametitle{Solução 2: \emph{Bubble Sort} (gráfico das duas implementações)}
\begin{figure}[h]
	\centering
	\includegraphics[height=0.75\paperheight]{pucrs-ec-poo-unidade_01-complexidade_de_algoritmos-laminas-grafico_bubble_sort2.jpg}
\end{figure}
\end{frame}

%-------------------------------------------------------
\begin{frame}\frametitle{Análise da eficiência de um algoritmo}
\begin{itemize}
	\item Medir o tempo depende de hardware e software (sistema operacional, por exemplo)
	\item Alternativa?\\
	\pause
	\textbf{Contar o número de operações (atribuição, operação aritmética, comparação, etc.)}
\end{itemize}
\end{frame}

%=======================================================
\section{Contagem de operações}

%-------------------------------------------------------
\begin{frame}\frametitle{Análise de algoritmos}
\begin{itemize}
	\item Não considera o tempo de execução
	\item Pode ser feita diretamente sobre o pseudocódigo de alto nível
	\item Consiste em contar quantas \textbf{operações primitivas} são executadas
	\begin{itemize}
		\item Operação primitiva: instrução de baixo nível com um tempo de execução constante
	\end{itemize}
	\item Assume-se que os tempos de execução de operações primitivas diferentes são similares
\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}\frametitle{Operações primitivas}
\begin{itemize}
	\item Atribuição de valores a variáveis
	\item Chamadas de métodos
	\item Operações aritméticas (por exemplo, adição de dois números)
	\item Comparação de dois números
	\item Acesso a um arranjo
	\item Retorno de um método
\end{itemize}
\end{frame}

%-------------------------------------------------------	
\begin{frame}[fragile]\frametitle{Exemplo 1}
\begin{itemize}
	\item Contar o número de operações para atribuir para cada posição v[i] de um arranjo unidimensional o resultado de i*2
\begin{verbatim}
v[0..10] : inteiro
for (i = 0; i < v.comprimento; i++)
    v[i] = i * 2
\end{verbatim}
	\pause
	\item Operação (multiplicação, atribuição e acesso às posições do arranjo): \textbf{n vezes (n = 10)}
	\pause
	\begin{figure}[h]
		\centering
		\includegraphics[height=0.4\paperheight]{pucrs-ec-poo-unidade_01-complexidade_de_algoritmos-laminas-grafico2.png}
	\end{figure}
\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}[fragile]\frametitle{Exemplo 2}
\begin{itemize}
	\item Contar o número de operações para atribuir para cada posição m[i,j] de um arranjo bidimensional o resultado de i*j
\begin{verbatim}
m[0..10][0..10] : inteiro
for (i=0; i<m.comprimento; i++)
    for (j=0; j<m[i].comprimento; j++)
        m[i][j] = i * j
\end{verbatim}
	\pause
	\item Operação (multiplicação, atribuição e acesso às posições do arranjo): \textbf{n*n vezes (n = 10)}
	\pause
	\begin{figure}[h]
		\centering
		\includegraphics[height=0.35\paperheight]{pucrs-ec-poo-unidade_01-complexidade_de_algoritmos-laminas-grafico3.png}
	\end{figure}
\end{itemize}
\end{frame}


%-------------------------------------------------------
\begin{frame}[fragile]\frametitle{Exercícios (1/2)}
Implementar e contar o número de operações das funções listadas a seguir.
\begin{columns}[T]
\begin{column}{0.5\linewidth}
\begin{enumerate}
	\item
{\small
\begin{verbatim}
int f1(n)
    r=0
    for (i=1; i<n; i++)
        r = r + 1
    return r
\end{verbatim}
}
	\item
{\small
\begin{verbatim}
int f2(n)
    r=0
    for (i=1; i<n; i++)
        for (j=i+1; j<n; j++)
            r = r + 2
    return r
\end{verbatim}
}
\end{enumerate}
\end{column}
\begin{column}{0.5\linewidth}
\begin{enumerate}
\setcounter{enumi}{2}
	\item
{\small
\begin{verbatim}
int f3(n)
    cont=0
    for (i=1; i<n; i++)
        for (j=1; j<n; j++)
            print i*j
            cont++
     return cont
\end{verbatim}
}
\end{enumerate}
\end{column}
\end{columns}
\end{frame}

%-------------------------------------------------------
\begin{frame}[fragile]\frametitle{Exercícios (2/2)}
\begin{columns}[T]
\begin{column}{0.5\linewidth}
\begin{enumerate}
\setcounter{enumi}{3}
	\item
{\small
\begin{verbatim}
int f4(n)
    r=0
    for (i=1; i<n; i++)
        for (j=i; j<2*i; j++)
            for (k=i; k<j; k++)
                r = r + 1
     return r
\end{verbatim}
}
	\item
{\small
\begin{verbatim}
int f5(n)
    r=0
    for (i=1; i<n; i++)
        for (j=i; j<i+3; j++)
            for (k=i; k<j; k++)
                r = r + 1
    return r
\end{verbatim}
}
\end{enumerate}
\end{column}
\begin{column}{0.5\linewidth}
\begin{enumerate}
\setcounter{enumi}{5}
	\item
{\small
\begin{verbatim}
int f6(n)
    if (n==0)
       return 1
    else
       return f6(n-1) + f6(n-1)
\end{verbatim}
}
\end{enumerate}
\end{column}
\end{columns}
\end{frame}

%=======================================================
\section{Funções}

%-------------------------------------------------------
\begin{frame}\frametitle{Funções}
\begin{itemize}
	\item Uma \textbf{classe de complexidade} é uma forma de agrupar algoritmos que apresentam complexidade similar. Por exemplo:
	\begin{itemize}
		\item Complexidade \textbf{constante}: o algoritmo sempre ocupa a mesma quantidade de recursos
		\item Complexidade \textbf{linear}: o algoritmo consome recursos de forma diretamente proporcional ao tamanho do problema
	\end{itemize}
\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}\frametitle{Funções}
\begin{itemize}
	\item Sete funções mais comuns usadas em análise de algoritmos:
	\begin{itemize}
		\item Constante: $1$
		\item Logaritmo: $\log n$
		\item Linear: $n$
		\item n-log-n: $n \log n$
		\item Quadrática: $n^2$
		\item Cúbica: $n^3$
		\item Exponencial: $a^n$
	\end{itemize}
\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}\frametitle{Função Constante: $1$}
\begin{itemize}
	\item Função mais simples
	\item $f(n) = c$
	\item Não importa o valor de $n$, sempre será igual ao valor da constante $c$
	\item Exemplo: função que recebe um arranjo de inteiros e retorna o valor do primeiro elemento multiplicado por 2
\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}\frametitle{Função Logaritmo: $\log n$}
\begin{itemize}
	\item $f(n) = \log_{2}n$
	\item O número de operações realizadas para solução do problema não cresce da mesma forma que $n$
	\begin{itemize}
		\item Se dobra o valor de $n$, o incremento do consumo é bem menor
	\end{itemize}
	\item Exemplo: conversão de número decimal para binário e pesquisa binária (\emph{binary search})
\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}\frametitle{Função Linear: $n$}
\begin{itemize}
	\item Se dobra o valor de $n$, dobra o consumo de recursos
	\item $f(n) = n$
	\item Exemplo: localizar um elemento em uma lista.
\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}\frametitle{Função n-log-n: $n \log n$}	
\begin{itemize}
	\item $f(n) = n \log n$
	\item Atribui para uma entrada $n$ o valor de $n$ multiplicado pelo logaritmo de base 2 de $n$
	\item Cresce mais rápido que a função linear e mais devagar que a função quadrática
	\item Exemplo: Algoritmos de ordenação mergesort e heapsort\\\url{http://www.sorting-algorithms.com/}
\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}\frametitle{Função Quadrática: $n^2$}
\begin{itemize}
	\item Função polinomial com expoente 2
	\item $f(n) = n^2$
	\item Não cresce de forma abrupta,mas dificultam o uso em problemas grandes.
	\item Exemplo: Ordenação com o algoritmo $bubblesort$
\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}\frametitle{Função Cúbica: $n^3$}
\begin{itemize}
	\item Função polinomial com expoente 3
	\item $f(n) = n^3$
	\item Aparece com menos frequência na análise de algoritmos do que as funções constante, linear ou quadrática
	\item Exemplo: multiplicar duas matrizes
\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}\frametitle{Função Exponencial: $a^n$}
\begin{itemize}
	\item Expoente é variável
	\item $f(n) = a^n$
	\item Algoritmos ``ruins'', crescem abruptamente
	\item Aplicável apenas em problemas pequenos.
	\item Exemplos: quebrar senhas com força bruta e listar todos os subconjuntos de um conjunto S
\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}\frametitle{Funções}
\begin{itemize}
	\item Taxas de crescimento para as funções usadas em análise de algoritmos
\end{itemize}

\begin{columns}[T]
\begin{column}{0.5\linewidth}
	\begin{figure}[h]
		\centering
		\includegraphics[height=0.6\paperheight]{pucrs-ec-poo-unidade_01-complexidade_de_algoritmos-laminas-grafico4.png}
	\end{figure}
\end{column}
\begin{column}{0.5\linewidth}
	\begin{figure}[h]
		\centering
		\includegraphics[height=0.6\paperheight]{pucrs-ec-poo-unidade_01-complexidade_de_algoritmos-laminas-grafico5.png}
	\end{figure}
\end{column}
\end{columns}

\end{frame}

%-------------------------------------------------------
\begin{frame}\frametitle{Funções}
\begin{itemize}
	\item Um problema é dividido em funções/métodos
	\begin{itemize}
		\item Cada função/método tem um ``custo'' diferente
		\item Estes custos são somados para determinar o custo total para solução do problema
	\end{itemize}
\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}\frametitle{Exercício 1}
\begin{itemize}
	\item Dois algoritmos para resolver o mesmo problema\\
$f_{1}(n) = 2n^2 + 5n$ operações\\
$f_{2}(n) = 500n + 4000$ operações
	\item Considere o número de operações de cada um para diferentes valores de $n$ (por exemplo, $n = 10$ e $n = 1000$)
	\item Qual é a melhor solução?
\end{itemize}
\end{frame}

%-------------------------------------------------------
\begin{frame}[fragile]\frametitle{Exercício 2} % Fonte: https://create.kahoot.it/details/2e37a282-4d9d-4902-8afc-9b827ed393fc
Qual a complexidade do algoritmo abaixo?
{\scriptsize
\begin{verbatim}
v[1..N] : inteiro
maximo = 0
for (i=1; i<=n; ++i)
    sum = 0   // sum = somatorio de x[i..j]
    for (j = i; j <= n; ++j)
        sum += x[j]
    maximo = max(maximo,sum)
\end{verbatim}
}
\begin{enumerate}[A]
	\item $O(n)$
	\item $O(n^2)$ % CERTA
	\item $O(n \log 2n)$
	\item $O(2n)$
\end{enumerate}
\end{frame}

%-------------------------------------------------------
\begin{frame}[fragile]\frametitle{Exercício 3} % Fonte: https://create.kahoot.it/details/2e37a282-4d9d-4902-8afc-9b827ed393fc
Qual a complexidade do algoritmo abaixo?
{\scriptsize
\begin{verbatim}
int busca(v[1..N] : inteiro, elem : inteiro)
    for (i = 1; i <= n; i++)
        if (elem == v[i])
           return i // elemento encontrado no indice i
    return -1  // elemento NAO encontrado
\end{verbatim}
}
\begin{enumerate}[A]
	\item $O(n)$ % CERTA
	\item $O(n^2)$
	\item $O(n \log 2n)$
	\item $O(2n)$
\end{enumerate}
\end{frame}

\begin{comment}
%-------------------------------------------------------
\begin{frame}\frametitle{Funções}
\begin{itemize}
	\item 
Exercício:
https://kahoot.com/

\end{comment}

%=======================================================
\section{Créditos}

%-------------------------------------------------------
\begin{frame}\frametitle{Créditos}
\begin{itemize}
	\item Estas lâminas contêm trechos de materiais criados e disponibilizados pela professora Isabe Harb Manssour.
\end{itemize}
\end{frame}

%-------------------------------------------------------
\end{document}

